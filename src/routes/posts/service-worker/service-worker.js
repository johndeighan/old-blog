// Generated by CoffeeScript 2.7.0
var ASSETS, CACHE;

import {
  build,
  files,
  version
} from '$service-worker';

// --- Create a unique cache name for this deployment
CACHE = `cache-${version}`;

ASSETS = [
  ...build, // the app itself
  ...files // everything in `static`
];

self.addEventListener('install', (event) => {
  var addFilesToCache;
  // --- Create a new cache and add all files to it
  addFilesToCache = async function() {
    var cache;
    cache = (await caches.open(CACHE));
    return (await cache.addAll(ASSETS));
  };
  return event.waitUntil(addFilesToCache());
});

self.addEventListener('activate', (event) => {
  var deleteOldCaches;
  // --- Remove previous cached data from disk
  deleteOldCaches = async function() {
    var key, results;
    results = [];
    for (key in (await caches.keys())) {
      if (key !== CACHE) {
        results.push((await caches.delete(key)));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  return event.waitUntil(deleteOldCaches());
});

self.addEventListener('fetch', (event) => {
  var respond;
  // --- ignore POST requests etc
  if (event.request.method !== 'GET') {
    return;
  }
  respond = async function() {
    var cache, err, response, url;
    url = new URL(event.request.url);
    cache = (await caches.open(CACHE));
    // --- `build`/`files` can always be served from the cache
    if (ASSETS.includes(url.pathname)) {
      return cache.match(event.request);
    }
    try {
      // --- for everything else, try the network first, but
      //     fall back to the cache if we're offline
      response = (await fetch(event.request));
      if (response.status === 200) {
        cache.put(event.request, response.clone());
      }
      return response;
    } catch (error) {
      err = error;
      return cache.match(event.request);
    }
  };
  return event.respondWith(respond());
});
